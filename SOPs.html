<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>sops</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="SOPs_files/libs/clipboard/clipboard.min.js"></script>
<script src="SOPs_files/libs/quarto-html/quarto.js"></script>
<script src="SOPs_files/libs/quarto-html/popper.min.js"></script>
<script src="SOPs_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="SOPs_files/libs/quarto-html/anchor.min.js"></script>
<link href="SOPs_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="SOPs_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="SOPs_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="SOPs_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="SOPs_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="sops" class="level1">
<h1>Standard Operating Procedures</h1>
<p><a href="documents/SOP_Bleaching_V2.qmd"><strong>Population Synchronization of Worms by Bleaching</strong></a><br>
To synchronise populations of <em>C. elegans</em> by bleaching to obtain individuals in the same life stage. The same procedure likely works for <em>C. briggsae</em> and <em>C. tropicalis</em>.</p>
<p><strong>SOP_Fluorescence_Aggregation_Imaging</strong></p>
<p>-&gt; For imaging behaviour of <em>C. elegans</em> using the AxioZoom fluorescence microscope.&nbsp;</p>
<p><strong>SOP_Freezing_Bacteria</strong></p>
<p>-&gt; Bacterial glycerol stocks are important for long-term storage. For more frequent and immediate use, bacteria can be streaked on LB agar plates that can be maintained at 4°C for a few weeks.</p>
<p><strong>SOP_Pouring_Agar_Plates</strong></p>
<p>-&gt; Nematode Growth Medium (NGM) agar is used for regular laboratory maintenance of <em>C. elegans</em>. This protocol uses the Dose It peristaltic pump to pour NGM agar into Petri dishes.</p>
<p><strong>SOP_pH_Meter</strong></p>
<p>-&gt; This protocol is for using and calibrating the Hanna Instruments™ pH Laboratory Meter HI 2211-02 in ZT0638.</p>
<p><strong>SOP_Twostep_OP50</strong></p>
<p>-&gt; For culturing OP50 bacteria to be used as food in regular maintenance of <em>C. elegans</em>, <em>C. briggsae</em> and <em>C. tropicalis</em>. The purpose of two-step inoculation is to harvest the bacteria at its exponential, or log growth phase.</p>
<p><strong>SOP_Streaking_Bacteria</strong></p>
<p>-&gt; This protocol should be used if you want to isolate an individual clonal population (single colony) of bacteria from a frozen glycerol stock. This protocol explains how to isolate a single bacterial colony by streaking it onto a LB agar plate.</p>
<p><strong>SOP_Spot_Bleaching</strong></p>
<p>-&gt; If you only need a small number of semi-synchronized <em>C. elegans</em> or if you simply need to remove yeast or bacterial contaminants, this protocol is more simple and less time-consuming than full-scale bleaching.</p>
<p><strong>SOP_NoPeptone_Agar_Plates</strong></p>
<p>-&gt; Imaging plates are made with NGM containing no bactopeptone to prevent the seeded bacteria from growing too much. High bacterial growth would result in poor imaging. This protocol uses the Dose It peristaltic pump to pour 35mm imaging plates.</p>
<p><strong>SOP_Measuring_Optical_Density_of_OP50</strong></p>
<p>-&gt; Before OP50 bacteria is aliquoted into small falcon tubes, the optical density (OD600) should be measured using a spectrophotometer for documentation purposes.</p>
<p><strong>SOP_Making_LB_Agar_Plates</strong></p>
<p>-&gt; LB agar plates (with or without antibiotic) are used for streaking bacteria for growth as single colonies for subsequent culturing as worm food.</p>
<p><strong>SOP_M9_Solution</strong></p>
<p>-&gt; Used to maintain <em>C. elegans</em> in liquid for short periods of time.</p>
<p><strong>SOP_Bacteria_Liquid_Culture</strong></p>
<p>-&gt; Used for inoculating an overnight culture bacteria in liquid LB.</p>
<p><strong>SOP_HighDensity_Agar_Plates</strong></p>
<p>-&gt; For growth of worms at a high density on NGM agar plates. This protocol uses the Dose It peristaltic pump to pour NGM agar into Petri dishes.</p>
<p><strong>SOP_Freezing_Worms</strong></p>
<p>-&gt; For long-term storage of <em>C. elegans</em> in liquid nitrogen (−196°C) and at -80°C.</p>
<p><strong>SOP_Loopbio_Imaging</strong></p>
<p>-&gt; For imaging aggregation behaviour worms using the Loopbio rigs.</p>
<p><strong>SOP_Concentrated_Bacteria_Stock</strong></p>
<p>-&gt; For making a concentrated stock of bacteria for use in liquid culture of <em>C. elegans</em>.</p>
<p><strong>SOP_Lysis</strong></p>
<p>-&gt; For extracting DNA from Nematodes</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>